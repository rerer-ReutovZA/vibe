# FAQ - Часто задаваемые вопросы

## Общие вопросы

### Q: Что такое CS 1.6 Data Capture DLL?
**A:** Это DLL модуль на C++, который перехватывает игровые данные из памяти Counter-Strike 1.6 и отправляет их через WebSocket в реальном времени. Это позволяет создавать внешние приложения для мониторинга игры, аналитики и визуализации данных.

### Q: Для чего это нужно?
**A:** Основные применения:
- Стриминг оверлеи с игровой статистикой
- Аналитика игровых сессий
- Обучающие инструменты
- Создание пользовательских дашбордов
- Исследования и разработка AI ботов
- Записи матчей с расширенной статистикой

### Q: Это чит?
**A:** Нет. DLL только читает данные из памяти, но не изменяет их. Однако использование подобных инструментов может быть расценено античит-системами как нарушение.

---

## Безопасность и VAC

### Q: Могу ли я получить VAC бан за использование этой DLL?
**A:** Да, возможно. Valve Anti-Cheat (VAC) может обнаружить DLL injection и чтение памяти процесса. Мы настоятельно рекомендуем использовать DLL ТОЛЬКО на:
- Локальных серверах
- Серверах без VAC защиты
- В режиме offline

### Q: Как избежать бана?
**A:** Единственный надежный способ - не использовать DLL на серверах с VAC. Если вам нужна статистика для стриминга, рассмотрите официальные API или другие разрешенные методы.

### Q: Можно ли сделать DLL необнаружимой?
**A:** Технически возможно применить техники обфускации и стелс-инжекции, но мы не предоставляем такой функционал. Проект создан для образовательных целей.

---

## Установка и настройка

### Q: Как установить DLL?
**A:** 
1. Скомпилируйте DLL из исходников или скачайте готовую сборку
2. Используйте DLL инжектор (например, Extreme Injector, Process Hacker)
3. Запустите CS 1.6
4. Инжектируйте DLL в процесс `hl.exe`
5. DLL автоматически начнет работу

### Q: Какие инжекторы вы рекомендуете?
**A:**
- **Extreme Injector** - простой и надежный
- **Process Hacker** - продвинутый, с дополнительными функциями
- **Xenos Injector** - поддерживает различные методы инжекции

### Q: DLL не загружается. Что делать?
**A:** Проверьте:
1. DLL собрана для правильной архитектуры (x86 для CS 1.6)
2. Все зависимости доступны (Visual C++ Redistributable)
3. У вас есть права администратора
4. Антивирус не блокирует DLL
5. Логи в файле `cs16_datacapture.log`

### Q: Где искать логи?
**A:** Лог файл `cs16_datacapture.log` создается в той же папке, где находится `hl.exe` (обычно в папке установки CS 1.6).

---

## Компиляция

### Q: Как скомпилировать DLL?
**A:** 
```bash
cd dll
mkdir build && cd build
cmake ..
cmake --build . --config Release
```
Подробные инструкции в [dll/README.md](README.md)

### Q: Какие требования для компиляции?
**A:**
- Windows 10/11
- Visual Studio 2019 или новее с C++ компонентами
- CMake 3.15+
- Windows SDK

### Q: Можно ли скомпилировать на Linux?
**A:** Нет, DLL использует Windows-специфичные API. Однако вы можете скомпилировать для Wine, но это требует дополнительной работы.

### Q: Ошибки компиляции. Что делать?
**A:** Убедитесь:
1. У вас установлены все компоненты Visual Studio (Desktop development with C++)
2. CMake версии 3.15 или выше
3. Переменная PATH настроена правильно
4. Проверьте логи CMake на наличие ошибок

---

## Использование

### Q: Как подключиться к WebSocket серверу?
**A:** DLL автоматически подключается к `localhost:8080`. Для изменения адреса отредактируйте `src/dllmain.cpp` и пересоберите:
```cpp
static const std::string WS_HOST = "localhost";
static const int WS_PORT = 8080;
```

### Q: Как создать WebSocket сервер?
**A:** Используйте готовый пример:
```bash
node dll/examples/test_websocket_server.js
```
Или создайте свой на любом языке программирования. Примеры в [INTEGRATION_EXAMPLES.md](INTEGRATION_EXAMPLES.md)

### Q: Какой формат данных отправляет DLL?
**A:** JSON формат:
```json
{
  "players": [...],
  "bomb": {...},
  "events": [...],
  "roundNumber": 5,
  "roundTime": 120.5
}
```
Полное описание в [README.md](README.md)

### Q: Как часто DLL отправляет данные?
**A:** По умолчанию каждые 100ms (10 раз в секунду). Можно изменить через функцию `SetUpdateInterval(ms)`.

### Q: DLL подключается к серверу, но не отправляет данные?
**A:** Проблема скорее всего в смещениях памяти. См. следующий раздел.

---

## Смещения памяти

### Q: Что такое смещения памяти?
**A:** Это адреса в памяти процесса, где хранятся игровые данные (имена игроков, фраги, статус бомбы и т.д.). Они специфичны для каждой версии игры.

### Q: Где найти смещения для моей версии CS 1.6?
**A:** Нужно искать самостоятельно с помощью Cheat Engine. Подробное руководство: [MEMORY_OFFSETS_GUIDE.md](MEMORY_OFFSETS_GUIDE.md)

### Q: DLL отправляет пустые или неправильные данные?
**A:** Это значит, что смещения памяти устарели или неправильные. Вам нужно найти актуальные смещения для вашей версии игры.

### Q: Как обновить смещения в коде?
**A:** Отредактируйте метод `initializeOffsets()` в файле `src/game_data_capture.cpp`:
```cpp
offsets_.playerListBase = baseAddr + 0xYOURADDRESS;
offsets_.playerKillsOffset = 0xYOUROFFSET;
// и т.д.
```

### Q: Существуют ли базы данных смещений?
**A:** Нет официальной базы. Смещения различаются для каждой версии и сборки игры. Некоторые сообщества (unknowncheats.me, guidedhacking.com) могут иметь информацию.

---

## Производительность

### Q: DLL влияет на FPS?
**A:** Минимально. DLL работает в отдельных потоках и использует асинхронную отправку данных. Влияние обычно < 1-2 FPS.

### Q: Как уменьшить нагрузку?
**A:** 
1. Увеличьте интервал обновления: `SetUpdateInterval(200)` (5 раз в секунду)
2. Уменьшите уровень логирования в коде
3. Отключите неиспользуемые функции захвата

### Q: DLL вызывает лаги?
**A:** Не должна. Если лаги присутствуют:
1. Проверьте логи на ошибки
2. Убедитесь, что WebSocket сервер отвечает
3. Проверьте использование CPU через Task Manager
4. Возможно проблема в неправильных смещениях (бесконечные циклы чтения)

---

## Разработка и расширение

### Q: Как добавить новые данные для захвата?
**A:**
1. Найдите смещения в памяти с помощью Cheat Engine
2. Добавьте поля в структуры в `include/game_types.h`
3. Обновите методы захвата в `src/game_data_capture.cpp`
4. Обновите JSON сериализацию в `src/websocket_client.cpp`

### Q: Можно ли использовать полноценный WebSocket протокол?
**A:** Да. Подключите библиотеку WebSocket++ или Boost.Beast и обновите класс `WebSocketClient`. Текущая реализация использует простой TCP для упрощения.

### Q: Как добавить шифрование?
**A:** Интегрируйте SSL/TLS библиотеку (OpenSSL, mbedTLS) и оберните сокет соединение в SSL контекст.

### Q: Можно ли записывать данные в базу данных?
**A:** Да, напишите свой WebSocket сервер (Node.js, Python), который будет сохранять данные в БД. Примеры в [INTEGRATION_EXAMPLES.md](INTEGRATION_EXAMPLES.md)

---

## Troubleshooting

### Q: "Failed to connect to WebSocket server"
**A:** 
1. Убедитесь, что сервер запущен на порту 8080
2. Проверьте файрвол
3. Попробуйте telnet: `telnet localhost 8080`
4. Проверьте логи сервера

### Q: "Failed to get game module base address"
**A:** 
1. Убедитесь, что CS 1.6 запущен
2. DLL инжектирована в правильный процесс (`hl.exe`)
3. Попробуйте альтернативное имя модуля в коде (`hw.dll`)

### Q: "Read access violation" или краши игры
**A:** 
1. Смещения памяти неправильные
2. Проверка валидности адресов не работает
3. Убедитесь, что читаете из правильных адресов
4. Используйте `isValidAddress()` перед чтением

### Q: WebSocket постоянно переподключается
**A:** 
1. Сервер возвращает ошибку или закрывает соединение
2. Проверьте логи сервера
3. Отключите auto-reconnect для отладки
4. Проверьте формат отправляемых данных

### Q: Антивирус блокирует DLL
**A:** Это нормально для инжектируемых DLL. Добавьте DLL в исключения антивируса или временно отключите его. Только для доверенных DLL!

---

## Продвинутые темы

### Q: Как реализовать pattern scanning?
**A:** Используйте метод `findPattern()` в `MemoryReader`. Пример:
```cpp
std::vector<uint8_t> pattern = {0x55, 0x8B, 0xEC};
std::string mask = "xxx";
uintptr_t addr = memoryReader_->findPattern(pattern, mask, baseAddr, 0x100000);
```

### Q: Как работать с многоуровневыми указателями?
**A:** Читайте указатели последовательно:
```cpp
uintptr_t ptr1, ptr2, finalAddr;
memoryReader_->readMemory(baseAddr + 0x100, ptr1);
memoryReader_->readMemory(ptr1 + 0x50, ptr2);
memoryReader_->readMemory(ptr2 + 0x20, finalAddr);
```

### Q: Как обрабатывать разные версии игры?
**A:** Создайте профили смещений для каждой версии и определяйте версию по хешу или сигнатуре исполняемого файла.

### Q: Можно ли захватывать звуковые события?
**A:** Теоретически да, но нужно найти где в памяти хранится информация о звуковых событиях и обрабатывать их аналогично другим данным.

---

## Юридические вопросы

### Q: Это легально?
**A:** Чтение памяти процесса само по себе легально для образовательных целей и личного использования. Однако это может нарушать Terms of Service игры/платформы.

### Q: Могу ли я использовать это на стриме?
**A:** На свой риск. Использование может привести к бану аккаунта. Лучше использовать официальные инструменты или API.

### Q: Можно ли продавать приложения на основе этой DLL?
**A:** Проект под MIT лицензией, поэтому технически можно. Но учтите юридические риски и ToS игры.

---

## Контакты и поддержка

### Q: Где получить помощь?
**A:** 
1. Прочитайте документацию: README.md, MEMORY_OFFSETS_GUIDE.md
2. Проверьте Issues на GitHub
3. Проверьте логи DLL
4. Сообщества: unknowncheats.me, guidedhacking.com (для технических вопросов)

### Q: Как сообщить о баге?
**A:** Создайте Issue на GitHub с:
- Описанием проблемы
- Шагами для воспроизведения
- Логами DLL
- Версией CS 1.6
- Версией DLL

### Q: Как предложить улучшение?
**A:** Создайте Issue с тегом "enhancement" или отправьте Pull Request.

---

## Дополнительные ресурсы

- [Cheat Engine Tutorial](https://wiki.cheatengine.org/)
- [Game Hacking Guide](https://guidedhacking.com/)
- [Unknown Cheats Forum](https://unknowncheats.me/)
- [HLSDK Documentation](https://developer.valvesoftware.com/)
- [CS 1.6 SDK on GitHub](https://github.com/ValveSoftware/halflife)

---

**Не нашли ответ на свой вопрос?** Создайте Issue на GitHub или обратитесь к сообществу.
